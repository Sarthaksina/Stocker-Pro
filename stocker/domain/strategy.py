"""Strategy domain model for STOCKER Pro.

This module defines the core domain entities related to trading strategies,
strategy parameters, and strategy types.
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional, Any, Union
from uuid import uuid4

import pandas as pd


class StrategyType(str, Enum):
    """Types of trading strategies.
    
    Defines the possible types of trading strategies supported by the system.
    """
    MOMENTUM = "momentum"            # Momentum-based strategies
    MEAN_REVERSION = "mean_reversion"  # Mean reversion strategies
    TREND_FOLLOWING = "trend_following"  # Trend following strategies
    BREAKOUT = "breakout"            # Breakout strategies
    PATTERN = "pattern"              # Chart pattern strategies
    FUNDAMENTAL = "fundamental"      # Fundamental analysis strategies
    STATISTICAL = "statistical"      # Statistical arbitrage strategies
    ML_BASED = "ml_based"            # Machine learning based strategies
    CUSTOM = "custom"                # Custom user-defined strategies


@dataclass
class StrategyParameters:
    """Parameters for a trading strategy.
    
    This class represents the configurable parameters for a trading strategy,
    which can be adjusted to customize the strategy's behavior.
    
    Attributes:
        lookback_period: Number of periods to look back for calculations
        threshold: Threshold value for signal generation
        stop_loss: Stop loss percentage
        take_profit: Take profit percentage
        position_size: Position size as a percentage of portfolio
        max_positions: Maximum number of positions
        custom_params: Dictionary of additional custom parameters
    """
    lookback_period: int = 20
    threshold: float = 1.0
    stop_loss: float = 5.0
    take_profit: float = 10.0
    position_size: float = 5.0
    max_positions: int = 10
    custom_params: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert the parameters to a dictionary representation."""
        result = {
            "lookback_period": self.lookback_period,
            "threshold": self.threshold,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "position_size": self.position_size,
            "max_positions": self.max_positions,
        }
        
        # Add custom parameters
        result.update(self.custom_params)
        
        return result
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "StrategyParameters":
        """Create parameters from a dictionary.
        
        Args:
            data: Dictionary with parameter values
            
        Returns:
            StrategyParameters object
        """
        # Extract standard parameters
        standard_params = {
            "lookback_period": data.get("lookback_period", 20),
            "threshold": data.get("threshold", 1.0),
            "stop_loss": data.get("stop_loss", 5.0),
            "take_profit": data.get("take_profit", 10.0),
            "position_size": data.get("position_size", 5.0),
            "max_positions": data.get("max_positions", 10),
        }
        
        # Extract custom parameters
        custom_params = {}
        for key, value in data.items():
            if key not in standard_params:
                custom_params[key] = value
        
        return cls(
            **standard_params,
            custom_params=custom_params
        )


class SignalType(str, Enum):
    """Types of trading signals.
    
    Defines the possible types of trading signals that can be generated by strategies.
    """
    BUY = "buy"              # Buy signal
    SELL = "sell"            # Sell signal
    HOLD = "hold"            # Hold signal (no action)
    STRONG_BUY = "strong_buy"  # Strong buy signal
    STRONG_SELL = "strong_sell"  # Strong sell signal


@dataclass
class Signal:
    """Trading signal.
    
    This class represents a trading signal generated by a strategy,
    indicating a potential trading opportunity.
    
    Attributes:
        id: Unique signal ID
        strategy_id: ID of the strategy that generated the signal
        symbol: Stock symbol
        date: Date when the signal was generated
        type: Signal type
        price: Price at which the signal was generated
        confidence: Confidence level of the signal (0-100)
        metadata: Additional metadata about the signal
    """
    id: str = field(default_factory=lambda: str(uuid4()))
    strategy_id: str
    symbol: str
    date: datetime = field(default_factory=datetime.now)
    type: SignalType
    price: float
    confidence: float = 50.0  # 0-100 scale
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert the signal to a dictionary representation."""
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "date": self.date.isoformat(),
            "type": self.type.value,
            "price": self.price,
            "confidence": self.confidence,
            "metadata": self.metadata
        }


@dataclass
class Strategy:
    """Strategy domain entity.
    
    This class represents a trading strategy as a business entity,
    including its configuration, parameters, and performance metrics.
    
    Attributes:
        id: Unique strategy ID
        name: Strategy name
        description: Strategy description
        type: Strategy type
        parameters: Strategy parameters
        owner_id: ID of the strategy owner
        created_at: Creation date
        updated_at: Last update date
        is_active: Whether the strategy is active
        performance_metrics: Dictionary of performance metrics
    """
    id: str = field(default_factory=lambda: str(uuid4()))
    name: str
    description: str = ""
    type: StrategyType
    parameters: StrategyParameters = field(default_factory=StrategyParameters)
    owner_id: Optional[str] = None
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    is_active: bool = True
    performance_metrics: Dict[str, Any] = field(default_factory=dict)
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        """Generate trading signals based on the strategy.
        
        This is a placeholder method that should be implemented by specific strategy classes.
        
        Args:
            data: DataFrame with price data
            
        Returns:
            List of generated signals
        """
        raise NotImplementedError("This method should be implemented by specific strategy classes")
    
    def update_performance(self, metrics: Dict[str, Any]) -> None:
        """Update the strategy's performance metrics.
        
        Args:
            metrics: Dictionary of performance metrics
        """
        self.performance_metrics.update(metrics)
        self.updated_at = datetime.now()
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert the strategy to a dictionary representation."""
        return {
            "id": self.id,
            "name": self.name,
            "description": self.description,
            "type": self.type.value,
            "parameters": self.parameters.to_dict(),
            "owner_id": self.owner_id,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
            "is_active": self.is_active,
            "performance_metrics": self.performance_metrics
        }


@dataclass
class MomentumStrategy(Strategy):
    """Momentum trading strategy.
    
    This class implements a momentum-based trading strategy, which generates
    signals based on price momentum indicators.
    
    Additional parameters:
        momentum_period: Period for momentum calculation
        rsi_period: Period for RSI calculation
        rsi_overbought: RSI overbought threshold
        rsi_oversold: RSI oversold threshold
    """
    type: StrategyType = StrategyType.MOMENTUM
    
    def __post_init__(self):
        """Initialize momentum-specific parameters."""
        # Set default momentum parameters if not already set
        if "momentum_period" not in self.parameters.custom_params:
            self.parameters.custom_params["momentum_period"] = 14
        if "rsi_period" not in self.parameters.custom_params:
            self.parameters.custom_params["rsi_period"] = 14
        if "rsi_overbought" not in self.parameters.custom_params:
            self.parameters.custom_params["rsi_overbought"] = 70
        if "rsi_oversold" not in self.parameters.custom_params:
            self.parameters.custom_params["rsi_oversold"] = 30
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        """Generate momentum-based trading signals.
        
        Args:
            data: DataFrame with price data
            
        Returns:
            List of generated signals
        """
        signals = []
        
        # Ensure data has required columns
        if not all(col in data.columns for col in ["close", "high", "low"]):
            return signals
        
        # Calculate momentum
        momentum_period = self.parameters.custom_params.get("momentum_period", 14)
        data["momentum"] = data["close"].pct_change(momentum_period)
        
        # Calculate RSI (simplified calculation)
        rsi_period = self.parameters.custom_params.get("rsi_period", 14)
        delta = data["close"].diff()
        gain = delta.where(delta > 0, 0)
        loss = -delta.where(delta < 0, 0)
        avg_gain = gain.rolling(window=rsi_period).mean()
        avg_loss = loss.rolling(window=rsi_period).mean()
        rs = avg_gain / avg_loss.where(avg_loss != 0, 1)
        data["rsi"] = 100 - (100 / (1 + rs))
        
        # Generate signals
        rsi_overbought = self.parameters.custom_params.get("rsi_overbought", 70)
        rsi_oversold = self.parameters.custom_params.get("rsi_oversold", 30)
        threshold = self.parameters.threshold
        
        for i in range(momentum_period + rsi_period, len(data)):
            date = data.index[i]
            price = data["close"].iloc[i]
            momentum = data["momentum"].iloc[i]
            rsi = data["rsi"].iloc[i]
            
            # Generate buy signal
            if momentum > threshold and rsi < rsi_oversold:
                signal = Signal(
                    strategy_id=self.id,
                    symbol=data.get("symbol", ""),
                    date=date,
                    type=SignalType.BUY,
                    price=price,
                    confidence=min(100, max(0, 50 + (momentum * 10))),
                    metadata={
                        "momentum": momentum,
                        "rsi": rsi
                    }
                )
                signals.append(signal)
            
            # Generate sell signal
            elif momentum < -threshold and rsi > rsi_overbought:
                signal = Signal(
                    strategy_id=self.id,
                    symbol=data.get("symbol", ""),
                    date=date,
                    type=SignalType.SELL,
                    price=price,
                    confidence=min(100, max(0, 50 + (abs(momentum) * 10))),
                    metadata={
                        "momentum": momentum,
                        "rsi": rsi
                    }
                )
                signals.append(signal)
        
        return signals


@dataclass
class MeanReversionStrategy(Strategy):
    """Mean reversion trading strategy.
    
    This class implements a mean reversion trading strategy, which generates
    signals based on price deviations from a moving average.
    
    Additional parameters:
        ma_period: Period for moving average calculation
        std_dev_multiplier: Standard deviation multiplier for bands
    """
    type: StrategyType = StrategyType.MEAN_REVERSION
    
    def __post_init__(self):
        """Initialize mean reversion-specific parameters."""
        # Set default mean reversion parameters if not already set
        if "ma_period" not in self.parameters.custom_params:
            self.parameters.custom_params["ma_period"] = 20
        if "std_dev_multiplier" not in self.parameters.custom_params:
            self.parameters.custom_params["std_dev_multiplier"] = 2.0
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        """Generate mean reversion-based trading signals.
        
        Args:
            data: DataFrame with price data
            
        Returns:
            List of generated signals
        """
        signals = []
        
        # Ensure data has required columns
        if "close" not in data.columns:
            return signals
        
        # Calculate moving average and bands
        ma_period = self.parameters.custom_params.get("ma_period", 20)
        std_dev_multiplier = self.parameters.custom_params.get("std_dev_multiplier", 2.0)
        
        data["ma"] = data["close"].rolling(window=ma_period).mean()
        data["std_dev"] = data["close"].rolling(window=ma_period).std()
        data["upper_band"] = data["ma"] + (data["std_dev"] * std_dev_multiplier)
        data["lower_band"] = data["ma"] - (data["std_dev"] * std_dev_multiplier)
        
        # Generate signals
        for i in range(ma_period, len(data)):
            date = data.index[i]
            price = data["close"].iloc[i]
            ma = data["ma"].iloc[i]
            upper_band = data["upper_band"].iloc[i]
            lower_band = data["lower_band"].iloc[i]
            
            # Generate buy signal
            if price < lower_band:
                # Calculate distance from lower band as percentage
                distance = (lower_band - price) / lower_band * 100
                confidence = min(100, max(50, 50 + distance * 5))
                
                signal = Signal(
                    strategy_id=self.id,
                    symbol=data.get("symbol", ""),
                    date=date,
                    type=SignalType.BUY,
                    price=price,
                    confidence=confidence,
                    metadata={
                        "ma": ma,
                        "upper_band": upper_band,
                        "lower_band": lower_band,
                        "distance": distance
                    }
                )
                signals.append(signal)
            
            # Generate sell signal
            elif price > upper_band:
                # Calculate distance from upper band as percentage
                distance = (price - upper_band) / upper_band * 100
                confidence = min(100, max(50, 50 + distance * 5))
                
                signal = Signal(
                    strategy_id=self.id,
                    symbol=data.get("symbol", ""),
                    date=date,
                    type=SignalType.SELL,
                    price=price,
                    confidence=confidence,
                    metadata={
                        "ma": ma,
                        "upper_band": upper_band,
                        "lower_band": lower_band,
                        "distance": distance
                    }
                )
                signals.append(signal)
        
        return signals
